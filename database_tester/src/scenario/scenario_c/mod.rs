use crate::impl_get_connection;
use crate::metrics::MetricsRecorder;
use crate::scenario::scenario_c::generator::{SystemMetrics, SystemMetricsGenerator};
use crate::scenario::Scenario;
use crate::testcase::{Database, SystemConfiguration};
use async_trait::async_trait;
use chrono::{DateTime, Duration, Utc};
use db::{
	DatabaseConnectionInfluxDB, DatabaseConnectionMongoDB, DatabaseConnectionPostgres,
	DatabaseConnectionTimescaleDB,
};
use log::{debug, info};
use rand::rngs::SmallRng;
use rand::{Rng, SeedableRng};
use std::net::IpAddr;
use std::sync::Arc;
use std::time::Instant;

mod db;
mod generator;

#[async_trait]
trait DatabaseConnection {
	async fn initialize_schema(&mut self) -> anyhow::Result<()>;
	async fn import_data(
		&mut self,
		data: Box<dyn Iterator<Item = Vec<(DateTime<Utc>, SystemMetrics)>> + Send + 'static>,
	) -> anyhow::Result<()>;

	async fn query_combined_cpu_load_per_minute(&mut self) -> anyhow::Result<()>;
	async fn query_all_metrics(&mut self) -> anyhow::Result<()>;
	async fn query_all_instances_with_cpu_load_higher_than_95_and_memory_usage_higher_than_2350000(
		&mut self,
	) -> anyhow::Result<()>;
}

pub struct ScenarioC {
	duration: usize,
	max_instances: usize,
	new_instance_probability: f64,
	start_time: DateTime<Utc>,
	metrics_recorder: Arc<MetricsRecorder>,
}

impl ScenarioC {
	// With the used rand-library version these constants generate 142030961 metrics with roughly
	// 160 concurrently running instances (43195 instances in total over time)
	const SEED: u64 = 23987421;
	const MAX_INSTANCES: usize = 500;
	const NEW_INSTANCE_PROBABILITY: f64 = 0.05;
	const START_TIME: DateTime<Utc> = DateTime::from_timestamp(1735693200, 0).unwrap(); // 2025-01-01 00:00:00
	const DURATION: usize = 60 * 60 * 24 * 10; // 1 day

	pub fn new(metrics_recorder: Arc<MetricsRecorder>) -> Self {
		Self {
			duration: Self::DURATION,
			max_instances: Self::MAX_INSTANCES,
			new_instance_probability: Self::NEW_INSTANCE_PROBABILITY,
			start_time: Self::START_TIME,
			metrics_recorder,
		}
	}

	impl_get_connection!();
}

#[async_trait]
impl Scenario for ScenarioC {
	fn get_name(&self) -> &'static str {
		"Szenario C: Monitoring kurzlebiger Dienste"
	}

	fn get_queries(&self) -> &'static [&'static str] {
		&[
			"combined_cpu_load_per_minute",
			"all_metrics",
			"all_instances_with_cpu_and_mem",
		]
	}

	fn get_system_configurations(&self) -> &'static [SystemConfiguration] {
		&[
			SystemConfiguration {
				cpu_cores: 4,
				memory: 16384,
			},
			SystemConfiguration {
				cpu_cores: 8,
				memory: 16384,
			},
			SystemConfiguration {
				cpu_cores: 16,
				memory: 16384,
			},
		]
	}

	async fn init(
		&self,
		database: &Database,
		ip_addr: &IpAddr,
		password: Option<&str>,
	) -> anyhow::Result<()> {
		let mut connection = self.get_connection(database, ip_addr, password).await?;

		connection.initialize_schema().await?;

		let generator = MetricGenerator::new(
			Self::SEED,
			self.max_instances,
			self.new_instance_probability,
			self.duration,
			self.start_time,
		);
		connection.import_data(Box::new(generator)).await?;

		info!("Generated {} metrics", unsafe { METRICS_GENERATED });
		Ok(())
	}

	async fn run(
		&self,
		database: &Database,
		run_identifier: &str,
		query: &str,
		ip_addr: &IpAddr,
		password: Option<&str>,
	) -> anyhow::Result<()> {
		let mut connection = self.get_connection(database, ip_addr, password).await?;

		self.metrics_recorder.start_measurement(run_identifier);
		let start = Instant::now();
		match query {
			"combined_cpu_load_per_minute" => {
				connection.query_combined_cpu_load_per_minute().await?
			}
			"all_metrics" => connection.query_all_metrics().await?,
			"all_instances_with_cpu_and_mem" => {
				connection
					.query_all_instances_with_cpu_load_higher_than_95_and_memory_usage_higher_than_2350000(
					)
					.await?
			}
			_ => unreachable!(),
		}
		let duration = start.elapsed();
		self.metrics_recorder.add_latency_metric(duration);
		self.metrics_recorder.stop_measurement();

		Ok(())
	}
}

/// Generator for system metrics.
///
/// This generator produces a stream of system metrics that simulate a semi-realistic workload.
/// The metrics are generated by a combination of CPU and memory metrics.
///
/// Each iteration represents 100ms of time.
pub struct MetricGenerator {
	instances: Vec<(usize, SystemMetricsGenerator)>,
	max_instances: usize,
	new_instance_probability: f64,
	iteration: usize,
	max_iterations: usize,
	rng: SmallRng,
	start_time: DateTime<Utc>,
}

impl MetricGenerator {
	/// Creates a new instance of MetricGenerator
	///
	/// # Arguments
	///
	/// * `max_instances` - Maximum number of instances to simulate
	/// * `new_instance_probability` - Probability of a new instance being created
	/// * `max_iterations` - Maximum number of iterations
	/// * `start_time` - Start time of the simulation
	pub fn new(
		seed: u64,
		max_instances: usize,
		new_instance_probability: f64,
		max_iterations: usize,
		start_time: DateTime<Utc>,
	) -> Self {
		Self {
			instances: Vec::new(),
			max_instances,
			new_instance_probability,
			iteration: 0,
			max_iterations,
			rng: SmallRng::seed_from_u64(seed),
			start_time,
		}
	}
}

static mut METRICS_GENERATED: u64 = 0;

impl Iterator for MetricGenerator {
	type Item = Vec<(DateTime<Utc>, SystemMetrics)>;

	fn next(&mut self) -> Option<Self::Item> {
		self.instances.retain(|(i, _)| *i > self.iteration);

		debug!(
			"Iteration: {}, Instances: {}",
			self.iteration,
			self.instances.len()
		);

		if self.iteration >= self.max_iterations {
			return None;
		}

		if self.instances.len() < self.max_instances
			&& self.rng.random_bool(self.new_instance_probability)
		{
			let life = self.iteration + (self.rng.random_range(1.0..=10.0) * 60.0 * 10.0) as usize; // 1-10 minutes
			debug!("Creating new instance with life: {}", life);
			self.instances
				.push((life, SystemMetricsGenerator::new(self.rng.random())));
		}

		let mut records = Vec::with_capacity(self.max_instances);

		for (_, instance) in &mut self.instances {
			let metrics = instance.next().unwrap();

			records.push((
				self.start_time + Duration::milliseconds((self.iteration * 100) as i64),
				metrics,
			));

			unsafe {
				METRICS_GENERATED += 1;
			}
		}

		self.iteration += 1;

		Some(records)
	}
}
