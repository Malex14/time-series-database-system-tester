use rand::distr::Uniform;
use rand::rngs::SmallRng;
use rand::{Rng, SeedableRng};
use rand_distr::Distribution;
use rand_distr::Normal;

const BASE_LOAD: f64 = 0.2;
const LOAD_VARIATION: f64 = 0.01;
const RETURN_TO_BASE_LOAD_AMOUNT: f64 = 0.005;
const SPIKE_PROBABILITY: f64 = 0.001;
const SPIKE_LENGTH_MU: f64 = 200.;
const SPIKE_LENGTH_SIGMA: f64 = SPIKE_LENGTH_MU / 0.4;
const SPIKE_BASE_MU: f64 = 0.8;
const SPIKE_BASE_SIGMA: f64 = 0.15;
const RETURN_TO_SPIKE_BASE_LOAD_AMOUNT: f64 = 0.02;

/// A generator for CPU metrics.
///
/// This generator produces a stream of CPU load values that simulate a semi-realistic workload.
/// The load values are generated by a combination of a base load, random spikes, and random variations.
///
/// The generator is configured with the following parameters:
///
/// - `base_load`: The base load of the CPU. This is the average load that the CPU will have.
/// - `load_distribution`: The distribution of the random variations of the load. This is a uniform
///   distribution with a range of `[-LOAD_VARIATION, LOAD_VARIATION]`.
/// - `return_to_base_load_amount`: The amount of the base load that the load will return to each
///   iteration.
/// - `spike_probability`: The probability of a spike occurring in each iteration.
/// - `spike_duration_distribution`: The distribution of the duration of the spikes. This is a normal
///   distribution with a mean of `SPIKE_LENGTH_MU` and a standard deviation of `SPIKE_LENGTH_SIGMA`.
/// - `spike_base_distribution`: The distribution of the base load of the spikes. This is a normal
///   distribution with a mean of `SPIKE_BASE_MU` and a standard deviation of `SPIKE_BASE_SIGMA`.
/// - `return_to_spike_base_load_amount`: The amount of the base load of the spikes that the load
///   will return to each iteration.
pub struct CPUMetricsGenerator {
	pub base_load: f64,
	pub load_distribution: Uniform<f64>,
	pub return_to_base_load_amount: f64,
	pub spike_probability: f64,
	pub spike_duration_distribution: Normal<f64>,
	pub spike_base_distribution: Normal<f64>,
	pub return_to_spike_base_load_amount: f64,

	rand: SmallRng,
	spike_state: Option<SpikeState>,
	load: f64,
	i: usize,
}

struct SpikeState {
	until: usize,
	amount: f64,
}

impl CPUMetricsGenerator {
	pub fn new(seed: u64) -> Self {
		Self {
			base_load: BASE_LOAD,
			load_distribution: Uniform::new(-LOAD_VARIATION, LOAD_VARIATION).unwrap(),
			return_to_base_load_amount: RETURN_TO_BASE_LOAD_AMOUNT,
			spike_probability: SPIKE_PROBABILITY,
			spike_duration_distribution: Normal::new(SPIKE_LENGTH_MU, SPIKE_LENGTH_SIGMA).unwrap(),
			spike_base_distribution: Normal::new(SPIKE_BASE_MU, SPIKE_BASE_SIGMA).unwrap(),
			return_to_spike_base_load_amount: RETURN_TO_SPIKE_BASE_LOAD_AMOUNT,

			rand: rand::rngs::SmallRng::seed_from_u64(seed),
			spike_state: None,
			load: BASE_LOAD,
			i: 0,
		}
	}
}

impl Iterator for CPUMetricsGenerator {
	type Item = f64;

	fn next(&mut self) -> Option<Self::Item> {
		self.load += self.load_distribution.sample(&mut self.rand);

		self.load = (if let Some(spike_state) = &self.spike_state {
			self.load * (1. - self.return_to_spike_base_load_amount)
				+ spike_state.amount * self.return_to_spike_base_load_amount
		} else {
			self.load * (1. - self.return_to_base_load_amount)
				+ self.base_load * self.return_to_base_load_amount
		})
		.clamp(0., 1.);

		if let Some(SpikeState { until, .. }) = self.spike_state {
			if until < self.i {
				self.spike_state = None;
			}
		}

		if self.rand.random_bool(self.spike_probability) {
			let spike_duration = self.spike_duration_distribution.sample(&mut self.rand);
			let spike_base = self.spike_base_distribution.sample(&mut self.rand);
			self.spike_state = Some(SpikeState {
				until: self.i + spike_duration as usize,
				amount: spike_base,
			});
		}

		self.i += 1;

		Some(self.load)
	}
}

const BASE_USED_MU: f64 = 2e6;
const BASE_USED_SIGMA: f64 = 5e5;
const USED_VARIATION: f64 = 2000.;
const RETURN_TO_BASE_USED_AMOUNT: f64 = 5e-5;

/// A generator for memory metrics.
///
/// This generator produces a stream of memory used values that simulate a semi-realistic workload.
/// The used values are generated by a combination of a base used amount and random variations.
///
/// The generator is configured with the following parameters:
///
/// - `base_used`: The base amount of memory used. This is the average amount of memory that will be used.
/// - `used_distribution`: The distribution of the random variations of the used memory. This is a uniform
///   distribution with a range of `[-USED_VARIATION, USED_VARIATION]`.
/// - `return_to_base_used_amount`: The amount of the base used memory that the used memory will return to each
///   iteration.
pub struct MemoryMetricsGenerator {
	pub base_used: f64,
	pub used_distribution: Uniform<f64>,
	pub return_to_base_used_amount: f64,

	rand: SmallRng,
	used: f64,
}

impl MemoryMetricsGenerator {
	pub fn new(seed: u64) -> Self {
		let mut rand = SmallRng::seed_from_u64(seed);
		Self {
			base_used: rand.sample(Normal::new(BASE_USED_MU, BASE_USED_SIGMA).unwrap()),
			used_distribution: Uniform::new(-USED_VARIATION, USED_VARIATION).unwrap(),
			return_to_base_used_amount: RETURN_TO_BASE_USED_AMOUNT,

			rand,
			used: BASE_USED_MU,
		}
	}
}

impl Iterator for MemoryMetricsGenerator {
	type Item = u64;

	fn next(&mut self) -> Option<Self::Item> {
		self.used += self.used_distribution.sample(&mut self.rand);

		self.used = (self.used * (1. - self.return_to_base_used_amount)
			+ self.base_used * self.return_to_base_used_amount)
			.max(0.);

		Some(self.used as u64)
	}
}

pub struct SystemMetrics {
	pub id: u32,
	pub cpu: f64,
	pub memory: u64,
}

/// A generator for system metrics.
///
/// This generator produces a stream of system metrics that simulate a semi-realistic workload.
/// The metrics are generated by a combination of CPU and memory metrics.
///
/// The generator is configured with the number of CPUs in the system.
pub struct SystemMetricsGenerator {
	id: u32,
	cpu: CPUMetricsGenerator,
	memory: MemoryMetricsGenerator,
}

impl SystemMetricsGenerator {
	pub fn new(seed: u64) -> Self {
		let mut rand = rand::rngs::SmallRng::seed_from_u64(seed);
		static mut ID: u32 = 0;
		Self {
			id: unsafe {
				ID += 1;
				ID
			},
			cpu: CPUMetricsGenerator::new(rand.random()),
			memory: MemoryMetricsGenerator::new(rand.random()),
		}
	}
}

impl Iterator for SystemMetricsGenerator {
	type Item = SystemMetrics;

	fn next(&mut self) -> Option<Self::Item> {
		Some(SystemMetrics {
			id: self.id,
			cpu: self.cpu.next().unwrap(),
			memory: self.memory.next().unwrap(),
		})
	}
}
